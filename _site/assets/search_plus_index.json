{"/pages/installation/": {
    "title": "⚓安装",
    "keywords": "Jekyll",
    "url": "/pages/installation/",
    "body": "aomaker 已上传到pypi ，所以安装非常简单。 第一次安装 pip install aomaker 安装最新版本 pip install -U aomaker 查看是否安装成功 直接命令行输入aomaker aomaker 能看到aomaker logo即安装成功。"
  },"/pages/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/": {
    "title": "✈️快速开始",
    "keywords": "Jekyll",
    "url": "/pages/%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/",
    "body": "创建项目 在命令行输入aomaker startproject projectname即可。 项目结构 apis：接口层，存放接口文件 conf config.yaml：配置文件，如环境、账户、数据库连接、全局变量等信息 utils.yaml：工具配置，如企业微信webhook配置 data api _data：单接口用例测试数据 scenario_data：场景用例测试数据 database aomaker.db： 全局变量和依赖变量存储库 logs：日志存放 reports：测试报告 testcases test_api：单接口用例文件 test_scenario：场景用例文件 yamlcase：yaml自动转代码 conftest.py：pytest插件注册 login.py：登录配置 pytest.ini：pytest配置文件 run.py：项目主启动文件 修改配置文件 conf/config.yaml # 当前运行环境 env: test # test环境配置 test: account: pwd: 123456 user: aomaker002 host: http://test.aomaker.com # release环境配置 release: account: pwd: 123456 user: aomaker001 host: http://release.aomaker.com 在这里需要配置好项目的环境信息，上述示例是最基础的配置，如果有其它配置，直接在对应环境下加键值对即可。 注：account 和host 是最基础的配置，请不要更改key 的名字。 配置登录 关于登录和请求头鉴权的处理，需要在项目根目录下的login.py模块下配置处理，login.py模块下预置了一个Login的class和两个方法：login和make_headers login.py from requests import request from aomaker.fixture import BaseLogin class Login(BaseLogin): def login(self): resp_login = {} return resp_login def make_headers(self, resp_login): headers = { 'Cookie': f'csrftoken=aomakerniubility'} return headers 需要注意的是，上面是一个基础模板，login和make_headers两个方法必须实现，你需要改的是两个方法内的内部逻辑，即login方法 需要构造登录，并return登录接口的响应；make_headers方法需要构造鉴权所需要的头部信息。 此外，BaseLogin中读取了config.yaml配置文件中的环境信息、账户信息以及host信息，所以在Login中可以直接引用。 当login.py中配置好了登录，在启动测试任务前，会自动去登录和配置请求头，请求头的配置会被读取的BaseApi的实例属性中，所有的接口类是继承于BaseApi的，所以所有的接口都可以直接调用基类BaseApi中的所有实例属性，包括： class BaseApi: def __init__(self): # cache表的连接对象 self.cache = Cache() # config表的连接对象 self.config = Config().get_all() # 配置文件中当前环境的host self._host = self.config.get('host') # login.py中配置的请求头 self._headers = self.cache.get('headers') 编写ao 基于aomaker的核心编排思想：ao，api object，即所有接口都被封装成对象，同类型的接口为一个class，比如集群的增删改查接口，那么“集群”这个class下，对应着“增、删、改、查”四个method，也就是四个接口，每个method下，就是对这个接口的http协议进行填充，举个例子： # 所有接口类都继承于BaseApi from aomaker.base.base_api import BaseApi # 作业类，作业相关的接口都封装在该类下 class Job(BaseApi): # 提交作业接口 def submit_hpc_job(self): body = { \"service\": \"hpc\", \"action\": \"job/submitJob\", } # 构造http请求协议体 # 需要注意的是： # 请求体中，不用指明host和headers，因为在baseapi中已经封装好了， # 当发送请求时，会自动加上host和headers http_data = { \"method\": \"post\", \"api_path\": \"/portal_api\", \"params\": {'action': 'job/submitJob'}, \"data\": { 'params': json.dumps(body) } } # 发送接口请求（Baseapi提供） # 返回json格式数据，如果响应数据不是json格式，会返回txt格式 # resp = self.send_http(http_data) return resp 编写case case文件编写在工程根目录下的testcases下，该目录下分为单接口case：test_api目录和场景case：test_scenario目录，根据自己需要在对应目录下编写case，这里以单接口为例： testcases/test_api/test_job.py import pytest import allure # 导入BaseTestcase基类，该类提供内置断言方式 from aomaker.base.base_testcase import BaseTestcase # 导入data_maker工具方法，帮助读取数据文件，进行数据驱动 from aomaker.aomaker import data_maker from apis.job import job # 测试类继承基类 class TestJob(BaseTestcase): @allure.title(\"提交hpc作业\") @pytest.mark.hpc # 解析数据文件，获取数据驱动的参数列表，data_maker接收三个参数： # 1.数据文件的相对路径（相对工程根目录） # 2.数据文件中的类名key # 3.数据文件中的方法名key @pytest.mark.parametrize(\"test_data\", data_maker(\"data/api_data/job.yaml\", \"job\", \"hpc_submit_job\")) def test_hpc_submit_job(self, test_data): resp = job.submit_hpc_job(test_data) ret_code = resp.get(\"ret_code\") # 基类提供的断言方法 self.assert_eq(ret_code, 0) self.assert_schema(resp, 'submit_hpc_job') 运行用例 测试用例提供两种运行方式： cli：arun 或aomaker run ，支持pytest的所有参数 run.py: run.py from aomaker.runner import run # 导入登录类 from login import Login if __name__ == '__main__': # 第一个参数为列表，接收pytest支持的所有参数 run(['-m ehpc'], login=Login()) 查看用例结果 aomaker 默认安装了pytest-allure 插件，运行完成后会自动收集allure 报告。（请确保运行环境已安装allure ） 报告会收集在reports 目录下： 如果不想使用allure ，也支持其它所有pytest 报告插件，可以自行使用。"
  },"/jekyll/2022-07-15-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5.html": {
    "title": "📢企业微信通知",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-15-%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E9%80%9A%E7%9F%A5.html",
    "body": "当执行完测试任务后，aomaker提供直接将测试报告发送到企业微信的功能。 使用方法 先在conf\\utils.yaml下配置企业微信的webhook utils.yaml wechat: webhook: https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxx 在run.py文件下， run.py from aomaker.runner import run # 导入企业微信通知类 from aomaker.send_msg.wechat import WeChatSend from login import Login if __name__ == '__main__': run(['-m demo'], login=Login()) # 发送测试报告到企业微信 WeChatSend().send_msg() WeChatSend类有几个可选实例属性： tester：可设置测试负责人名称 title：可设置通知标题 report_address：可设置查看报告详情地址 效果"
  },"/jekyll/2022-07-14-%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C.html": {
    "title": "集成数据库操作",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-14-%E9%9B%86%E6%88%90%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C.html",
    "body": "在做接口测试时，有时我们需要去查询业务数据库，做一些数据相关的校验，所以aomaker集成了一些数据库的相关操作，目前支持 sqlite和mysql两种数据库的一些常规操作。 如何使用？（以mysql为例） 先在配置文件conf/config.yaml中配置对应环境的数据库连接信息： config.yaml env: test test: account: pwd: test01 user: test01 host: http://test.aomaker.com # 配置数据库信息 mysql: host: localhost user: admin password: 123456 port: 3306 一般以pytest本地插件的方式去封装获取数据库连接对象的方法，在conftest.py下，封装一个mysql连接插件： conftest.py import pytest from aomaker.database.mysql import Mysql from aomaker.cache import config @pytest.fixture(scope=\"class\") def connect_mysql(): # 读取数据库配置信息 mysql_conf = config.get('mysql') # 创建mysql连接对象 db = Mysql(**mysql_conf) yield db # 测试结束后，关闭游标对象和数据库连接 db.close() 本地插件做好后，在用例层直接传入数据库连接对象： test_demo.py class TestDemo(BaseTestcase): # 以参数形式传入数据库连接插件 def test_demo(self, connect_mysql): # 获取数据库连接对象 db = connect_mysql # 通过数据连接对象操作数据库 sql_res = db.get_all(\"select * from xxx\") aomaker内置的mysql： class Mysql: def __init__(self, **kwargs): # 连接到数据库 try: self.con = pymysql.connect(charset=\"utf8\", **kwargs) except Exception as e: logger.error(f'数据库连接失败，连接参数：{kwargs}') raise e else: # 创建一个游标 self.cur = self.con.cursor() def get_one(self, sql): \"\"\"获取查询到的第一条数据\"\"\" self.con.commit() self.cur.execute(sql) return self.cur.fetchone() def get_all(self, sql): \"\"\"获取sql语句查询到的所有数据\"\"\" self.con.commit() self.cur.execute(sql) return self.cur.fetchall() def count(self, sql): \"\"\"获取sql语句查询到的数量\"\"\" self.con.commit() res = self.cur.execute(sql) return res def close(self): # 关闭游标对象 self.cur.close() # 断开连接 self.con.close() 如果有其它数据库需求，可以自行扩展，使用方式同上。"
  },"/jekyll/2022-07-13-%E6%96%AD%E8%A8%80%E6%89%A9%E5%B1%95.html": {
    "title": "🌊断言扩展",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-13-%E6%96%AD%E8%A8%80%E6%89%A9%E5%B1%95.html",
    "body": "内置断言 aomaker的所有测试类，都继承于aomaker提供的BaseTestcase类，这个测试类内置了一些常见的断言方式： class BaseTestcase: @staticmethod def assert_eq(actual_value, expected_value): \"\"\" equals \"\"\" try: assert actual_value == expected_value except AssertionError as e: logger.error(f\"eq断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_gt(actual_value, expected_value): \"\"\" greater than \"\"\" try: assert actual_value &gt; expected_value except AssertionError as e: logger.error(f\"gt断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_lt(actual_value, expected_value): \"\"\" less than \"\"\" try: assert actual_value &lt; expected_value except AssertionError as e: logger.error(f\"lt断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_neq(actual_value, expected_value): \"\"\" not equals \"\"\" try: assert actual_value != expected_value except AssertionError as e: logger.error(f\"neq断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_ge(actual_value, expected_value): \"\"\" greater than or equals \"\"\" try: assert actual_value &gt;= expected_value except AssertionError as e: logger.error(f\"ge断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_le(actual_value, expected_value): \"\"\" less than or equals \"\"\" try: assert actual_value &lt;= expected_value except AssertionError as e: logger.error(f\"le断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e @staticmethod def assert_contains(actual_value, expected_value): assert isinstance( expected_value, (list, tuple, dict, str, bytes) ), \"expect_value should be list/tuple/dict/str/bytes type\" try: assert expected_value in actual_value except AssertionError as e: logger.error(f\"contains断言失败，预期结果：{expected_value}，实际结果：{actual_value}\") raise e jsonschema介绍 此外，在2.0中还加入了jsonschema断言。 有时，我们的接口响应数据体积会非常庞大，字段也非常多，我们常规的断言可能只会去关注某几个关键字段，但是这不够健壮，有时候后端“悄悄咪咪”加了某个字段或者删了某个字段或者改了某个字段的类型，我们可能很难察觉到，这就会导致一些隐藏的bug逃逸，所以我们需要加强断言的健壮度，要对整个响应内容结构有一个基本的把控。 怎么做呢，这就需要用到jsonschema了。 JSON Schema是基于JSON格式，用于定义JSON数据结构以及校验JSON数据内容。 JSON Schema官网地址：http://json-schema.org/ 比如有一个json字符串： { \"name\": \"aomaker\", \"age\": 2, \"desc\": \"api framework\" } 这其中name和age是必填字段，字段类型分别是string和int，可选字段是desc，字段类型是string，假如我想要每个这样的json字符串，都符合上面的约束，那我怎么自动去校验呢？这就需要安装jsonschema的语法去写约束条件。 jsonchema语法 { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"TestInfo\", \"description\": \"some information about test\", \"type\": \"object\", \"properties\": { \"name\": { \"description\": \"Name of the test\", \"type\": \"string\" }, \"age\": { \"description\": \"age of test\", \"type\": \"integer\" } }, \"required\": [ \"name\", \"age\" ] } 开始校验 from jsonschema import validate x = { \"name\": \"aomaker\", \"age\": 2, \"desc\": \"api framework\" } schema = { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"title\": \"TestInfo\", \"description\": \"some information about test\", \"type\": \"object\", \"properties\": { \"name\": { \"description\": \"Name of the test\", \"type\": \"string\" }, \"age\": { \"description\": \"age of test\", \"type\": \"integer\" } }, \"required\": [ \"name\" ] } validate(x, schema) 如果校验通过，会没有返回，也没有报错。 假如不小心把age传成了字符串\"2\"，jsonschema检测到后，会立即报错 jsonschema.exceptions.ValidationError: '2' is not of type 'integer' Failed validating 'type' in schema['properties']['age']: {'description': 'age of test', 'type': 'integer'} On instance['age']: '2' 假如不小心没有传必填字段name，也会立即报错 jsonschema.exceptions.ValidationError: 'name' is a required property Failed validating 'required' in schema: {'$schema': 'http://json-schema.org/draft-04/schema#', 'description': 'some information about test', 'properties': {'age': {'description': 'age of test', 'type': 'integer'}, 'name': {'description': 'Name of the test', 'type': 'string'}}, 'required': ['name', 'age'], 'title': 'TestInfo', 'type': 'object'} On instance: {'age': 2, 'desc': 'api framework'} 通过这种手段是不是对我们测试过的接口更有信心了？ 扩展jsonschema断言 但是~有没有发现，jsonschema虽然很好，但是你得手动去写jsonschema校验语法，上面的示例还好，只有几个字段，但实际业务中，响应的字段可能要比这个多得多得多吧？那每个接口这么去写，成本也太高了！ 所以， aomaker提供了一种手段，可以自动去生成jsonschema校验语法~其实上文有提到过，aomaker.db数据库中，有一张表叫schema，其实它就是存放请求过的每个接口响应的jsonschema校验语法的。aomaker会自动记录每个请求第一次返回响应时的jsonschema，当在case层去做断言时，aomaker提供了一个jsonschema的断言在BaseTestcase中： class BaseTestcase: ... @staticmethod def assert_schema(instance, api_name): \"\"\" Assert JSON Schema :param instance: 请求响应结果 :param api_name: 存放在schema表中的对应key名 :return: \"\"\" json_schema = Schema().get(api_name) if json_schema is None: logger.error('jsonschema未找到！') raise SchemaNotFound(api_name) try: validate(instance, schema=json_schema) except ValidationError as msg: logger.error(msg) raise AssertionError 在case层进行断言： class TestJob(BaseTestcase): def test_hpc_submit_job(self): resp = job.submit_hpc_job() ret_code = resp.get(\"ret_code\") self.assert_eq(ret_code, 0) # schema断言 self.assert_schema(resp, 'submit_hpc_job') 会根据第二个参数，去schema表中取对应key的jsonschema schema表 需要注意的是，schema表中的jsonschema是在接口被调用的时候自动存储的，所以不需要手动操作，但是也是因为这个原因，有可能会存储接口异常时的响应的结构体，所以当要做jsonschema断言时，请检查该表，确保该表对应接口的jsonschema是符合预期的，当然，aomaker也提供了一个genson()方法，你可以通过该方法手动获取预期的jsonschema，然后自己存储到schema表中，schema表是固化不会自动清理的，你可以持续校正和维护该表。 如何使用genson 只需要传入json字符串，genson 会自动返回其jsonschema。 # 导入genson from aomaker.aomaker import genson x = { \"age\": 2, \"desc\": \"api framework\" } schema = genson(x) print(schema) # 输出： # {'$schema': 'http://json-schema.org/schema#', 'type': 'object', 'properties': {'age': {'type': 'integer'}, 'desc': {'type': 'string'}}, 'required': ['age', 'desc']}"
  },"/jekyll/2022-07-12-allure%E6%8A%A5%E5%91%8A%E4%BC%98%E5%8C%96.html": {
    "title": "👻Allure报告优化",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-12-allure%E6%8A%A5%E5%91%8A%E4%BC%98%E5%8C%96.html",
    "body": "自动收集allure报告 在每次执行完测试任务后，aomaker会自动收集allure的测试报告，报告位置在项目根目录下的reports\\html下，只需要打开该目录下的index.html文件即可。 自动记录用例的依赖调用信息 在查看allure报告时，可以看到每个case的测试步骤，即该case调用了哪些接口，并记录每个接口的请求、响应和响应时间等信息： 自动记录每个case的日志信息 aomaker会自动记录该case的所有相关日志信息"
  },"/jekyll/2022-07-11-%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.html": {
    "title": "🐼一键切换运行环境",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-11-%E4%B8%80%E9%94%AE%E5%88%87%E6%8D%A2%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83.html",
    "body": "测试环境一般会有多套，但是每套环境上的测试代码基本上是不会变的，所以我们需要有一个入口来控制切换当前测试代码的环境，这个入口在配置文件config.yaml中的env字段。 config.yaml # 控制环境切换入口 env: test test: account: pwd: test01 user: test01 host: http://test.aomaker.com release: account: pwd: test02 user: test02 host: http://release.aomaker.com 比如当前的测试环境是test，我现在想切换到release环境，那我只需要改env:release即可。 此外，aomaker还提供了cli命令来切换环境，用法： arun -e release或者aomaker run -e release，即通过-e env_name来切换"
  },"/jekyll/2022-07-11-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html": {
    "title": "📘日志系统",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-11-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F.html",
    "body": "aomaker提供了一套全新日志系统，这套日志系统将会记录aomaker所有关键节点信息，比如： 测试任务开始前的初始化配置 每个接口的入参、出参以及该接口的依赖调用信息和后置异步接口处理信息 多线程/进程模式下的每个子线程/进程的woker名称，线程/进程数量，每个线程/进程的启动参数 测试结束后，后置清理信息 此外，所有日志会同时分别输出到三个地方： 控制台 日志文件，所有日志会被记录到项目根目录下logs\\log.log中，记录级别为debug，rotation=10MB allure报告，每个接口请求的相关日志都会被记录且展示到allure报告中，详见下文 如果你需要在工程项目中记录一些自己需要的日志信息，直接导入aomaker提供的日志handler即可：from aomaker.log import logger，这个logger的用法和loguru完全一样。 控制台打印的日志级别默认为debug，如果你想改变默认级别，在命令行使用arun命令时，加上-l level即可，比如只想打印info及其以上的日志，使用arun -l info即可。 支持的级别： trace debug info success warning error critical"
  },"/jekyll/2022-07-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1.html": {
    "title": "🚀多任务",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-07-10-%E5%A4%9A%E4%BB%BB%E5%8A%A1.html",
    "body": "aomaker 提供了多线程和多进程两种方式来加速用例运行速度，提供了三种粒度来合理控制线程/进程worker，此外，多线程模式下，对allure 报告也做了完美兼容。 多线程（推荐） 启动方式 aomaker提供了两种启动多线程：CLI和run.py cli multi-run: --mp, --multi-process specifies a multi-process running mode. --mt, --multi-thread specifies a multi-thread running mode. --dist-suite DIST_SUITE specifies a dist mode for per worker. --dist-file DIST_FILE specifies a dist mode for per worker. --dist-mark DIST_MARK [DIST_MARK ...] specifies a dist mode for per worker. 命令行输入：arun --mt --dist-xxx xxx或者aomaker run --mt --dist-xxx run.py run.py from login import Login from aomaker.runner import threads_run if __name__ == '__main__': threads_run(['-m ehpc','-m hpc'], login=Login()) 分配模式 为了更加精细和合理的去分配任务给子线程，aomaker提供了三种分配模式，颗粒度由细到粗分别是： 按标记分配 即按照pytest提供的mark功能来分配任务给子线程，比如说你希望将标记为demo1、demo2、demo3的三组case分配给三个不同子线程去跑，那么你需要做的就是：提前给用例打上对应mark，然后： cli：arun --mt --dist-mark demo1 demo2 demo3 run.py: run.py from login import Login from aomaker.runner import threads_run if __name__ == '__main__': # 注意第一个参数传入的是列表 threads_run(['-m demo1','-m demo2','-m demo3'], login=Login()) 这样启动后，会开启三个子线程，去分别执行三组case。 注意： 1.每组mark下的case，一定要保证是独立的！ 2.提供多少个mark，就开启多少个线程 按测试模块分配 即按照测试文件来分配任务给子线程，比如在testcases\\test_api目录下有test_demo1.py、test_demo2.py、test_demo3.py三个测试模块，你希望这三个模块下的测试case分别由三个子线程接管执行，那么只需要： cli：arun --mt --dist-file testcases\\test_api，即告诉aomaker测试文件所在目录既可 run.py: run.py from login import Login from aomaker.runner import threads_run if __name__ == '__main__': # 注意第一个参数传入的是key名为path的字典 threads_run({\"path\":\"testcases/test_api\"}, login=Login()) 注意： 1.每个测试模块下的case，一定要保证是独立的！ 2.指定目录下有多少个测试模块，就开启多少个线程 按测试套件分配 即按照测试目录来分配任务给子线程，比如在testcases\\test_scenario目录下，有test_scenario1、test_scenario2、test_scenario3等三个测试目录，每个目录下还有若干测试模块，你希望这三个目录下的所有测试case分别由三个子线程接管执行，那么只需要： cli：arun --mt --dist-suite testcases\\test_scenario，即告诉aomaker测试套件所在目录既可 run.py: run.py from login import Login from aomaker.runner import threads_run if __name__ == '__main__': # 注意第一个参数传入的是字符串 threads_run(\"testcases/test_scenario\", login=Login()) 注意： 1.每个测试模块下的case，一定要保证是独立的！ 2.指定目录下有多少个测试套件，就开启多少个线程 多进程 aomaker目前暂时不支持在windows上创建多进程，linux是完美支持的。 启动方式 aomaker同样提供了两种启动多进程：CLI和run.py cli multi-run: --mp, --multi-process specifies a multi-process running mode. --mt, --multi-thread specifies a multi-thread running mode. --dist-suite DIST_SUITE specifies a dist mode for per worker. --dist-file DIST_FILE specifies a dist mode for per worker. --dist-mark DIST_MARK [DIST_MARK ...] specifies a dist mode for per worker. 命令行输入：arun --mp --dist-xxx xxx或者aomaker run --mp --dist-xxx run.py run.py from login import Login from aomaker.runner import processes_run if __name__ == '__main__': processes_run(['-m ehpc','-m hpc'], login=Login()) 分配模式 分配模式和多线程是一样的，区别是任务是分配给子进程，而不是子线程，具体分配模式请参考多线程。"
  },"/jekyll/2022-06-30-%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6.html": {
    "title": "📽️流量录制",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-30-%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6.html",
    "body": "如果不想写代码，也不想YAML ，那么用流量录制吧。 aomaker提供aomaker record或者arec来录制浏览器上的流量，录制完成后，会自动在yamlcase目录下生成一份xxx.yaml文件，其中记录了请求调用信息，因为记录的是原始流量，如果你想让case固化，则需要按照aomaker提供的YAML语法去将必要的参数进行参数化改造。 流量录制 1.打开浏览器（以Chrome为例），修改浏览器代理，将代理改为aomaker代理的端口地址。 有两种方式： 在浏览器设置中，修改浏览器代理为127.0.0.0:8082（不推荐） 安装浏览器插件Proxy SwitchyOmega，在插件中配置aomaker代理，并将代理切换为aomaker。 该插件可以非常轻松的管理代理并切换多个代理，非常方便好用，强烈推荐~ 2.进入到工程根目录下，执行aomaker record命令 格式： aomaker record [-h] [-f [FILTER_STR]] [-p [PORT]] [--flow-detail [LEVEL]] [--save_response [SAVE_RESPONSE]] [--save_headers [SAVE_HEADERS]] [file_name] aomaker record有一个简写命令，arec，两者等效。 执行aomaker record xxx.yaml后，aomaker将开始录制，此时只需要在浏览器中去操作需要转化成的自动化用例的业务场景即可。 录制完成后，在控制台按ctrl+c即可退出录制，输出的文件将放在工程根目录下的yamlcase目录中。 参数说明： -f, –filter_str 指定过滤字段，如-f \"console.shanhe.com\"，即表示代理只捕获url中含有\"console.shanhe.com\"的请求。 也可以同时指定多个过滤字段（过滤表达式参考下面），用” “分割即可，多个条件直接是”and”关系，如-f \"console.shanhe.com | ~hq method:/alarm\"，表示代理只捕获url中含有\"console.shanhe.com\"和请求头中有\"method:/alarm\"的请求。 附支持的过滤表达式： The following operators are understood: ~q Request ~s Response Headers: Patterns are matched against \"name: value\" strings. Field names are all-lowercase. ~a Asset content-type in response. Asset content types are: text/javascript application/x-javascript application/javascript text/css image/* application/x-shockwave-flash ~h rex Header line in either request or response ~hq rex Header in request ~hs rex Header in response ~b rex Expression in the body of either request or response ~bq rex Expression in the body of request ~bs rex Expression in the body of response ~t rex Shortcut for content-type header. ~d rex Request domain ~m rex Method ~u rex URL ~c CODE Response code. rex Equivalent to ~u rex -p,–port 指定aomaker代理端口，默认为8082。 –flow-detail 指定代理录制时记录日志信息的详细程度，一共0~4五个等级，详细程度依次递增，默认为0。 –save_response 指定录制流量时，是否保存响应结果，0为保存，1为不保存，默认为0。 –save_headers 指定录制流量时，是否保存请求头，0为保存，1为不保存，默认为1。 file_name 该参数为必填参数，指定录制流量的输出文件（YAML格式），需要注意指定文件名是需要添加后缀”.yaml”或”.yml”，文件将保存在项目根目录的yamlcase目录下。 har文件解析 如果不使用流量录制的方式，也可以通过浏览器F12，fiddler，Charles等场景抓包工具导出的.har文件，aomaker支持将har文件解析为YAML格式的功能，使用命令aomaker har2y即可。 参数说明： har_path 指定.har文件位置 yaml_path 指定转化的.yaml文件输出位置 –filter_str har文件转化为yaml文件时，所需要筛选的字段 –exclude_str har文件转化为yaml文件时，所需要排除的字段 –save_response 指定har文件转化为yaml文件时，是否保存响应结果，0为保存，1为不保存，默认为0。 –save_headers 指定har文件转化为yaml文件时，是否保存请求头，0为保存，1为不保存，默认为1。 修改YAML文件 录制的流量将保存在项目根目录的yamlcase目录下。 具体修改方法参考上一章。"
  },"/jekyll/2022-06-26-YAML.html": {
    "title": "📝编写YAML自动生成用例",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-06-26-YAML.html",
    "body": "aomaker提供了一套YAML模板语法，只要遵循规定语法，就可以不用写代码，直接通过YAML文件直接翻译为pytest风格的代码文件。 YAML语法介绍示例： testcase_class_name（必填）:指定测试类名称 description（可选）：用例描述 testcase_name（必填）：指定测试类下的测试方法名称 config（可选）：配置全局变量（配置文件中的全局变量），采用锚点标记的方式，下文可以直接引用 # 示例 # 标记锚点 config: &amp;config zone: \"self.config.get('zone')\" steps: - class_name: 'job' method_name: 'submit_job' request: ... data: params: service: hpc ... # 引用锚点 &lt;&lt;: *config # 等同于 zone：\"self.config.get('zone')\" steps：测试场景所包含的所有接口列表，列表中每一个元素即代表一个接口请求信息。（先后顺序代表接口请求顺序）steps中每个元素中至少有3个字段： class_name（必填）：指定ao的类名 method_name（必填）：指定ao类下的方法名，即接口名称 request（必填）: 接口请求信息 dependent_api（可选）：指明该接口的依赖接口，以列表形式接收，可以接收多个依赖，按先后顺序调用，每个依赖需要指明的参数如下： module（必填）: 依赖接口的所在模块，从apis模块导入，如apis.cluster api（必填）: 依赖接口的方法名称，如list extract（必填）: 需要从依赖接口中提取的参数 api_params（可选）：依赖接口所需要的参数，以字典形式接收 cluster_type: 'ehpc' # 示例 ... steps: - class_name: 'job' method_name: 'submit_job' dependent_api: # 指明依赖apis.cluster模块下的list方法 - module: apis.cluster api: list extract: \"cluster_id\" # 提取的参数名 api_params: cluster_type: 'ehpc' # 依赖接口所需要外部传入的参数 # 指明依赖apis.queue模块下的get_queue_list方法 - module: apis.queue api: get_queue_list extract: \"ehpc_queue_id\" dependent_params（可选）：指明该接口，需要从依赖接口中引用什么变量，并以什么jsonpath表达式提取。以列表形式接收（注意：当指明dependent_params，就必须同时指明dependent_api），每个依赖参数需要指明的参数如下： params（必填）：指明需要提取的依赖参数名 jsonpath（必填）：指明提取依赖参数的jsonpath表达式 index（可选）：jsonpath表达式提取出的值是list，可以根据自身需求指明需要提取哪个，默认值为0 # 示例 ... steps: - class_name: 'job' method_name: 'submit_job' dependent_api: ... dependent_params: - params: \"hpc_cluster_id\" # 依赖的参数名，注意下面引用时，就是用该名称 jsonpath: \"$..cluster_id\" # 从依赖接口的响应中根据该表达式提取依赖参数 - params: \"hpcqueue_id\" jsonpath: \"$..hpcqueue_id\" request: ... data: params: ... cluster_id: \"$hpc_cluster_id$\" # 通过$dependent_params中的params$进行引用 hpcqueue_id: \"$hpcqueue_id$\" data_driven（可选）：若该接口需要做数据驱动，可以通过该参数指明。 一个业务场景中，若多个接口都有data_driven参数，那么会自动进行参数组合，生成多条这个业务场景的测试数据。 不仅如此，凡是接口中带有data_driven，同时还会生成单接口测试数据。 # 示例 ... steps: - class_name: 'job' method_name: 'submit_job' data_driven: # 指明需要数据驱动的参数 cmd_line: [\"sleep 10 \",\"sleep 15 \",\"sleep 30 \",....] # 参数名：参数组 ... request: ... data: params: ... # test_data['cmd_line']的方式标记该参数是需要数据驱动的参数 cmd_line: \"test_data['cmd_line']\" assert（可选）：若需要对该接口的响应结果进行断言，可添加此参数，以列表形式接收。 # 示例 ... steps: - class_name: 'job' method_name: 'submit_job' ... request: ... assert: - eq: [ 'ret_code',0 ] # [jsonpath表达式（实际结果）,jsonpath索引(可不写，默认为0),预期结果] - neq: [ '$..hpcjob_uuid',null ] ps：支持的断言器可在_aomaker.base.base_testcase_中查看。 YAML完整实例 demo.yaml testcase_class_name: 'smoke2' description: 'hpc冒烟' testcase_name: 'hpc_smoke' config: &amp;config zone: \"self.config.get('zone')\" owner: \"self.config.get('owner')\" user_id: \"self.config.get('owner')\" run_user: \"self.config.get('owner')\" steps: - class_name: 'cluster' method_name: 'list' request: api_path: /portal_api/ method: POST params: action: cluster/list data: params: service: hpc action: cluster/list status: [ \"active\" ] sort_key: \"create_time\" verbose: 1 limit: 10 offset: 0 reverse: 1 cluster_type: \"ehpc\" &lt;&lt;: *config method: GET assert: - ge: [ '$..total_count',0 ] - class_name: cluster method_name: 'list_node' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 request: api_path: /portal_api/ method: POST params: action: cluster/listNodes data: params: action: cluster/listNodes service: hpc status: - active - stopped - pending sort_key: role reverse: 1 verbose: 1 limit: 10 offset: 0 cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config method: GET - class_name: 'user' method_name: 'user_list' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 request: api_path: /portal_api/ method: POST params: action: user data: params: service: hpc action: user/list limit: 10 offset: 0 sort_key: 'create_time' reverse: 1 cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config method: GET - class_name: 'user' method_name: 'add_user' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 data_driven: username: [ admin7,admin8,admin9 ] password: [ zhu!!jie,zhu@@jie,zhu@10jie ] request: api_path: /portal_api/ method: POST params: action: user/addUser data: params: service: hpc action: user/addUser mod: '755' username: \"test_data['username']\" password: \"test_data['password']\" cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config assert: - eq: [ 'ret_code',0 ] - class_name: 'user' method_name: 'modify_user' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 data_driven: username: [ admin7,admin8,admin9 ] request: api_path: /portal_api/ method: POST params: action: user/modifyUser data: params: service: hpc action: user/modifyUser new_password: Zhu@@@88jie username: \"test_data['username']\" cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config assert: - eq: [ 'ret_code',0 ] - class_name: 'user' method_name: 'delete_user' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 data_driven: username: [ admin7,admin8,admin9 ] request: api_path: /portal_api/ method: POST params: action: user/deleteUser data: params: service: hpc action: user/deleteUser username: \"test_data['username']\" cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config assert: - eq: [ 'ret_code',0 ] - class_name: 'queue' method_name: 'get_queue_list' dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" index: 0 request: api_path: /portal_api/ method: POST params: action: queue/ehpc/getQueueList data: params: service: hpc action: queue/ehpc/getQueueList limit: 10 offset: 0 sort_key: create_time reverse: 1 pageSize: 100 is_active: 1 cluster_id: \"$hpc_cluster_id$\" &lt;&lt;: *config method: GET assert: - eq: [ 'ret_code',0 ] - class_name: 'job' method_name: 'submit_ehpc_job' dependent_api: - module: apis.cluster api: list extract: \"cluster_id\" api_params: cluster_type: 'ehpc' - module: apis.queue api: get_queue_list extract: \"ehpc_queue_id\" dependent_params: - params: \"hpc_cluster_id\" jsonpath: \"$..cluster_id\" - params: \"hpcqueue_id\" jsonpath: \"$..hpcqueue_id\" data_driven: cmd_line: [ 'sleep 10','sleep 5', 'sleep 15' ] request: api_path: /portal_api/ method: POST params: action: job/submitJob data: params: service: hpc action: job/submitJob cmd_line_type: input name: 'mitm work' priority: 1 cmd_line: \"test_data['cmd_line']\" cluster_id: \"$hpc_cluster_id$\" hpcqueue_id: \"$hpcqueue_id$\" &lt;&lt;: *config assert: - eq: [ 'ret_code',0 ] - neq: [ 'hpcjob_uuid',null ] 将该demo.yaml文件放在工程根目录下的yamlcase文件夹下，然后命令行进入到工程根目录下，执行命令： aomaker mcase yamlcase\\demo.yaml后，aomaker会直接将yaml文件中的描述，转化为对应代码文件。 在apis目录下生成接口文件： cluster.py 数据文件包括单场景和业务场景： smoke2.yaml 生成的测试文件，包括单接口和业务场景case： test_smoke2.py"
  },"/jekyll/2022-05-24-async_api.html": {
    "title": "👽async_api装饰器用法",
    "keywords": "Jekyll",
    "url": "/jekyll/2022-05-24-async_api.html",
    "body": "当接口是异步接口，怎么做判断异步结果？ aomaker提供了@async_api来标记异步接口，示例如下： from aomaker.base.base_api import BaseApi from aomaker.aomaker import dependence, async_api from apis.cluster import cluster from utils import wait_job class Job(BaseApi): @async_api(wait_job, 'hpcjob_uuid') @dependence(cluster.get_cluster_list, 'hpc_cluster_id', cluster_type='hpc') def submit_hpc_job(self, test_data): ... return resp 使用步骤： from aomaker.aomaker import async_api导入@async_api装饰器 @async_api装饰器接收两个必传参数： 第一个参数，自己编写的轮询函数 第二个参数，从目标接口的响应中根据jsonpath表达式提取异步任务id 非必填参数，jsonpath表达式提取出的值是list，可以根据自身需求指明需要提取哪个，默认值为0 当一个接口被打上这个标记，那么会在接口被请求完成后，会开始执行自己编写的轮询函数，来判断该异步接口的异步任务结果是否得到预期结果。"
  },"/jekyll/2021-08-10-dependence.html": {
    "title": "🤖dependence装饰器用法",
    "keywords": "Jekyll",
    "url": "/jekyll/2021-08-10-dependence.html",
    "body": "当该接口有依赖接口，参数中有依赖上个接口的返回怎么办？ aomaker提供了一个依赖接口装饰器：@dependence，只需要标记依赖哪个接口，就会在请求该接口前，先去请求依赖接口，并将依赖的返回保存在cahce中，具体用法： import json from aomaker.base.base_api import BaseApi # 从aomaker导入depedence装饰器 from aomaker.aomaker import dependence # 导入依赖接口的接口对象 from apis.cluster import cluster class Job(BaseApi): # dependence标记依赖参数 @dependence(cluster.get_cluster_list, 'hpc_cluster_id', cluster_type='hpc') def submit_hpc_job(self, test_data): body = { # 从cache中获取依赖参数 \"cluster_id\": self.cache.get_by_jsonpath('hpc_cluster_id', jsonpath_expr='$..cluster_id'), \"hpcqueue_id\": self.cache.get_by_jsonpath('hpc_queue_id', jsonpath_expr='$..hpcqueue_id'), \"scheduler_queue_name\": \"medium\", \"cmd_line\": test_data[\"cmd_line\"] } http_data = { \"method\": \"post\", \"api_path\": \"/portal_api\", \"params\": {'action': 'job/submitJob'}, \"data\": { 'params': json.dumps(body) } } resp = self.send_http(http_data) return resp 使用步骤： from aomaker.aomaker import dependence导入装饰器 导入依赖接口对象 在模板接口上使用@dependence 装饰器，该装饰器接收2个必传参数： 第一个参数，依赖接口对象 第二个参数，需要从依赖接口响应中提取的参数名 如果依赖接口本身需要从外部传入参数，那么可以以关键字参数的形式传入 在body中，当需要引用依赖接口的参数时，直接调用self.cache.get_by_jsonpath方法，该方法接收2个必传参数： 第一个参数，依赖参数的参数名，即cache表中的key名 第二个参数，从依赖接口的响应中，提取出依赖参数值的jsonpath表达式 非必填，jsonpath表达式提取出的值是list，可以根据自身需求指明需要提取哪个，默认值为0 ​ 如果要提取的值，不需要使用jsonpath 来提取，也可以使用self.cache.get(key_name) 提取。 如果依赖的接口，是同一个类的方法怎么办？ @dependence的第一个参数需要以字符串的形式传入，如\"Job.job_list\"，同时，还需要告诉装饰器，接口对象来自哪个模块，传入imp_module=\"apis.job\"。 class Job(BaseApi): # dependence标记依赖参数 @dependence(\"Job.job_list\", 'job_id',imp_module=\"apis.job\") def submit_hpc_job(self, test_data): 如果有多个依赖接口，怎么办？ 只需要继续加“帽子”即可，需要注意装饰器的执行顺序是从上往下执行。 class Job(BaseApi): # 依赖从上往下执行 @dependence(cluster.get_cluster_list, 'hpc_cluster_id', cluster_type='hpc') @dependence(queue.get_queue_list, 'hpc_queue_id') def submit_hpc_job(self, test_data): ... return resp"
  },"/jekyll/2019-04-29-%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86.html": {
    "title": "☄️变量管理",
    "keywords": "Jekyll",
    "url": "/jekyll/2019-04-29-%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86.html",
    "body": "为了对多任务运行测试用例有更好的支持，aomaker 采用了本地数据库sqlite的方案来存储管理变量，sqlite是一个非常轻量的本地文件数据库，可以直接访问存储文件，而且不需要任何安装配置~ SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。它是一个零配置的数据库，这意味着与其他数据库不一样，您不需要在系统中配置。 就像其他数据库，SQLite 引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。 当使用aomaker创建完脚手架后，会在database目录下创建aomaker.db数据库文件，并且aomaker内置了三张数据表，来分别管理全局变量、接口依赖参数、jsonschema，这三张表分别是： config：存储配置文件中的全局变量，如账户信息，环境host等配置信息，当启动测试任务后，会根据当前选择的测试环境，自动读取config.yaml中的配置存到config表中，该配置会固化不清理，除非更改了测试环境。 cache：存储测试过程中上下游接口之间的依赖接口的响应，会搭配后文将要讲到的dependece装饰器使用 。当一个依赖接口被调用后，会存储它完整的response·，如果后续有其它接口也依赖这个接口，那么该接口将不会再被调用，而是直接从该接口存储的response中去读取需要的依赖参数。整个测试任务结束后，会自动清理cache表。 schema：存储接口的jsonschema信息，当一个接口第一次被调用后，会自动从它的response中解析出response.json()的jsonschema，在用例层进行断言时，可以对此次接口响应的结构体与schema表中存储的结构体进行比较，检测是否有参数变动。（后文细讲） 三张表的结构其实都非常简单，就是键值对： 在aomaker的baseapi中，初始化了cache和config两张表的连接对象，因为所有接口都是继承于baseapi的，所以所有接口都可以通过self.config和self.cache来拿到连接对象，当有了连接对象就可以通过封装好的set()和get()方法来存取变量了。 另外，三张表的数据读写，都是做了线程安全的，在多线程模式下也能保证数据安全。"
  },"/jekyll/2019-01-29-aomaker%E7%BB%93%E6%9E%84.html": {
    "title": "💎aomaker结构",
    "keywords": "Jekyll",
    "url": "/jekyll/2019-01-29-aomaker%E7%BB%93%E6%9E%84.html",
    "body": "BaseAPI提供API的公共操作，主要是请求封装，提供一些请求入参、出参的打印以及构造请求结构体。BaseTestcase提供case层的断言操作。 该两层已内置封装到aomaker中，只需要导入继承即可。"
  }}
